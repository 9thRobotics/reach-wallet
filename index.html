<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Reach 9D-RC Token Sale</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{background:#0a0a0a;color:#fff;font-family:sans-serif;text-align:center;padding:40px}
    button,input{font-size:16px;padding:12px 20px;margin:10px;border-radius:8px}
    button{cursor:pointer;background:#4caf50;border:none;color:#fff}
    button:hover{background:#45a049}
    .status{margin-top:10px;font-size:14px}
    .error{color:#f44336}
  </style>

  <!-- ▸ 100 % working, battle-tested libs -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3modal@1.9.5/dist/index.js"></script>
</head>
<body>

<h1>Reach 9D-RC Token</h1>

<button id="connectBtn">Connect Wallet</button>
<button id="disconnectBtn" style="display:none;background:#e53935">Disconnect</button>
<div id="walletStatus" class="status">Wallet not connected</div>

<h2>Buy Reach Tokens</h2>
<div id="priceInfo" class="status">Loading price information...</div>
<input  id="tokenAmount" type="number" min="1" step="1" placeholder="Whole Tokens Only" />
<div   id="estimate" class="status">Enter token amount</div>
<button id="buyBtn">Buy Now</button>
<div   id="txStatus" class="status"></div>

<button id="addBtn">➕ Add 9D-RC to Wallet</button>

<script>
/* ─── Config ─────────────────────────────────────────────── */
const SELLER_ADDRESS = "0x0557afA4318989702376D50B45547F953B7f9B21";
const TOKEN_ADDRESS  = "0x41a61cdcf40a074546423bae987b81733f3fbac5";
const CHAINLINK_FEED = "0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419";   // ETH/USD mainnet
const USD_PER_TOKEN  = 27;  // Base price
const TOKEN_DECIMALS = 18;
const TOKEN_SYMBOL   = "9D-RC";
const TOKEN_IMAGE    = "https://reachtoken.io/logo.png";
/* ─────────────────────────────────────────────────────────── */

let web3Modal, extProvider, provider, signer, user;
let buying = false;

/* ▸ Web3Modal setup (MetaMask + WalletConnect v1) */
const providerOptions = {
  walletconnect: {
    package: window.WalletConnectProvider.default,
    options: {
      rpc: { 1: "https://rpc.ankr.com/eth" },
      network: "ethereum"
      /*  ▸ If you have an Infura ID you can add: infuraId:"YOUR_INFURA_ID" */
    }
  }
};
web3Modal = new window.Web3Modal.default({ cacheProvider:false, providerOptions });

/* ▸ DOM bindings */
document.getElementById("connectBtn").onclick   = onConnect;
document.getElementById("disconnectBtn").onclick= onDisconnect;
document.getElementById("buyBtn").onclick       = buyTokens;
document.getElementById("addBtn").onclick       = addTokenToWallet;
document.getElementById("tokenAmount").addEventListener("input", updateEstimate);

/* ▸ Update price info display */
async function updatePriceInfo() {
  try {
    const tokenPrice = await getCurrentTokenPrice();
    const ethPrice = await getEthPrice();
    
    let infoText = `Current Price: $${tokenPrice.toFixed(2)} per token • ETH: $${ethPrice.toFixed(2)}`;
    
    try {
      const contractInfo = await getContractInfo();
      if (contractInfo) {
        const soldFormatted = Number(contractInfo.tokensSold) / 1e18;
        infoText += ` • ${soldFormatted.toFixed(0)} tokens sold`;
      }
    } catch (e) {
      // Ignore if contract info not available
    }
    
    document.getElementById("priceInfo").textContent = infoText;
  } catch (e) {
    document.getElementById("priceInfo").textContent = "Price information unavailable";
  }
}

// Update price info periodically
setInterval(updatePriceInfo, 30000); // Every 30 seconds
// Initial load when page loads
window.addEventListener('load', updatePriceInfo);

/* ▸ Connect wallet */
async function onConnect() {
  try {
    extProvider = await web3Modal.connect();          // opens modal immediately
    provider    = new ethers.providers.Web3Provider(extProvider);
    signer      = provider.getSigner();
    user        = await signer.getAddress();

    document.getElementById("walletStatus").textContent = `Connected: ${user}`;
    document.getElementById("connectBtn").style.display = "none";
    document.getElementById("disconnectBtn").style.display = "inline-block";
  } catch(e) { console.error("Connect failed:", e); }
}

/* ▸ Disconnect */
function onDisconnect() {
  if (extProvider && extProvider.close) extProvider.close();
  web3Modal.clearCachedProvider();
  provider = signer = extProvider = null;
  document.getElementById("walletStatus").textContent = "Wallet not connected";
  document.getElementById("connectBtn").style.display = "inline-block";
  document.getElementById("disconnectBtn").style.display = "none";
}

/* ▸ Chainlink price helper */
async function getEthPrice() {
  const abi=[{inputs:[],name:"latestRoundData",outputs:[
    {name:"roundId",type:"uint80"},{name:"answer",type:"int256"},
    {name:"startedAt",type:"uint256"},{name:"updatedAt",type:"uint256"},
    {name:"answeredInRound",type:"uint80"}],"stateMutability":"view","type":"function"}];
  const feed=new ethers.Contract(CHAINLINK_FEED,abi,provider);
  const rd=await feed.latestRoundData();
  return Number(rd.answer)/1e8;
}

/* ▸ Enhanced contract interface for bonding curve */
async function getContractInfo() {
  const abi = [{
    inputs: [],
    name: "getContractInfo",
    outputs: [
      {name: "currentPrice", type: "uint256"},
      {name: "totalTokensSold", type: "uint256"},
      {name: "ethPrice", type: "uint256"},
      {name: "contractBalance", type: "uint256"},
      {name: "buybackReserveAmount", type: "uint256"}
    ],
    stateMutability: "view",
    type: "function"
  }];
  
  try {
    const contract = new ethers.Contract(SELLER_ADDRESS, abi, provider);
    const info = await contract.getContractInfo();
    return {
      currentPrice: info.currentPrice,
      tokensSold: info.totalTokensSold,
      ethPrice: info.ethPrice,
      contractBalance: info.contractBalance,
      buybackReserve: info.buybackReserveAmount
    };
  } catch (e) {
    console.warn("Could not get contract info, using fallback:", e);
    return null;
  }
}

/* ▸ Get dynamic token price */
async function getCurrentTokenPrice() {
  try {
    const contractInfo = await getContractInfo();
    if (contractInfo) {
      // Price from contract is in USD with 18 decimals
      return Number(contractInfo.currentPrice) / 1e18;
    }
  } catch (e) {
    console.warn("Using fallback pricing:", e);
  }
  
  // Fallback to original pricing
  return USD_PER_TOKEN;
}

/* ▸ Live estimate with dynamic pricing */
async function updateEstimate() {
  const t = parseInt(document.getElementById("tokenAmount").value);
  if (!t || t<=0) { 
    document.getElementById("estimate").textContent="Enter whole number of tokens"; 
    return; 
  }
  
  try {
    const ethUsd = await getEthPrice();
    const tokenPriceUSD = await getCurrentTokenPrice();
    const totalUSD = t * tokenPriceUSD;
    const eth = totalUSD / ethUsd;
    
    // Show both current price and total cost
    document.getElementById("estimate").textContent =
      `≈ ${eth.toFixed(6)} ETH ($${totalUSD.toFixed(2)}) • Price: $${tokenPriceUSD.toFixed(2)}/token`;
      
    // Show additional info if available
    try {
      const contractInfo = await getContractInfo();
      if (contractInfo) {
        const soldFormatted = Number(contractInfo.tokensSold) / 1e18;
        document.getElementById("estimate").textContent += ` • ${soldFormatted.toFixed(0)} sold`;
      }
    } catch (e) {
      // Ignore if contract info not available
    }
    
  } catch { 
    document.getElementById("estimate").textContent="Price unavailable"; 
  }
}

/* ▸ Buy button with enhanced pricing */
async function buyTokens() {
  if (!signer) return alert("Connect wallet first.");
  if (buying)  return alert("Transaction pending…");
  const tok = parseInt(document.getElementById("tokenAmount").value);
  if (!tok||tok<=0) return alert("Enter valid token amount.");

  buying=true;
  try {
    const ethUsd = await getEthPrice();
    const tokenPriceUSD = await getCurrentTokenPrice();
    const totalUSD = tok * tokenPriceUSD;
    const ethNeeded = (totalUSD / ethUsd) * 1.02;  // +2% buffer for bonding curve price movement
    const ethValue = ethers.utils.parseEther(ethNeeded.toFixed(6));
    const minTok = ethers.utils.parseUnits(tok.toString(), TOKEN_DECIMALS);

    const abi=[{inputs:[{internalType:"uint256",name:"minTokens",type:"uint256"}],
                name:"buyTokens",outputs:[],stateMutability:"payable",type:"function"}];
    const seller=new ethers.Contract(SELLER_ADDRESS,abi,signer);

    document.getElementById("txStatus").textContent="⏳ Confirm in wallet…";
    const tx=await seller.buyTokens(minTok,{value:ethValue,gasLimit:300000}); // Increased gas for bonding curve
    document.getElementById("txStatus").textContent="⏳ Waiting for confirmation…";
    await tx.wait();
    document.getElementById("txStatus").textContent="✅ Purchase successful! Price may have increased.";
    document.getElementById("tokenAmount").value="";
    updateEstimate(); // Refresh estimate to show new price
  } catch (err) {
    const message = err?.error?.message || err?.reason || err?.message || "Transaction failed";
    document.getElementById("txStatus").textContent = `❌ ${message}`;
    console.error("Buy error:", err);
  }
  buying=false;
}

/* ▸ Quick-add token */
async function addTokenToWallet(){
  if(!window.ethereum) return;
  try{
    await window.ethereum.request({
      method:'wallet_watchAsset',
      params:{type:'ERC20',options:{
        address:TOKEN_ADDRESS,symbol:TOKEN_SYMBOL,
        decimals:TOKEN_DECIMALS,image:TOKEN_IMAGE}}
    });
  }catch(e){ if(e.code!==-32602) console.error("addToken:",e); }
}
</script>
</body>
</html>
